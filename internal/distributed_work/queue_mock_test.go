// Code generated by MockGen. DO NOT EDIT.
// Source: code.citik.ru/back/report-action/internal/distributed_work (interfaces: Queue,Consumer,Task)

// Package distributed_work is a generated GoMock package.
package distributed_work

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	go_version "github.com/hashicorp/go-version"
)

// MockQueue is a mock of Queue interface.
type MockQueue struct {
	ctrl     *gomock.Controller
	recorder *MockQueueMockRecorder
}

// MockQueueMockRecorder is the mock recorder for MockQueue.
type MockQueueMockRecorder struct {
	mock *MockQueue
}

// NewMockQueue creates a new mock instance.
func NewMockQueue(ctrl *gomock.Controller) *MockQueue {
	mock := &MockQueue{ctrl: ctrl}
	mock.recorder = &MockQueueMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQueue) EXPECT() *MockQueueMockRecorder {
	return m.recorder
}

// Ack mocks base method.
func (m *MockQueue) Ack(arg0 Task) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ack", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Ack indicates an expected call of Ack.
func (mr *MockQueueMockRecorder) Ack(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ack", reflect.TypeOf((*MockQueue)(nil).Ack), arg0)
}

// Delete mocks base method.
func (m *MockQueue) Delete(arg0 Task) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockQueueMockRecorder) Delete(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockQueue)(nil).Delete), arg0)
}

// Insert mocks base method.
func (m *MockQueue) Insert(arg0 TaskType, arg1 *go_version.Version, arg2 []byte, arg3 TaskOptions) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Insert", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Insert indicates an expected call of Insert.
func (mr *MockQueueMockRecorder) Insert(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockQueue)(nil).Insert), arg0, arg1, arg2, arg3)
}

// Release mocks base method.
func (m *MockQueue) Release(arg0 Task, arg1 TaskOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Release", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Release indicates an expected call of Release.
func (mr *MockQueueMockRecorder) Release(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Release", reflect.TypeOf((*MockQueue)(nil).Release), arg0, arg1)
}

// Take mocks base method.
func (m *MockQueue) Take() (Task, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Take")
	ret0, _ := ret[0].(Task)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Take indicates an expected call of Take.
func (mr *MockQueueMockRecorder) Take() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Take", reflect.TypeOf((*MockQueue)(nil).Take))
}

// MockConsumer is a mock of Consumer interface.
type MockConsumer struct {
	ctrl     *gomock.Controller
	recorder *MockConsumerMockRecorder
}

// MockConsumerMockRecorder is the mock recorder for MockConsumer.
type MockConsumerMockRecorder struct {
	mock *MockConsumer
}

// NewMockConsumer creates a new mock instance.
func NewMockConsumer(ctrl *gomock.Controller) *MockConsumer {
	mock := &MockConsumer{ctrl: ctrl}
	mock.recorder = &MockConsumerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConsumer) EXPECT() *MockConsumerMockRecorder {
	return m.recorder
}

// CanConsume mocks base method.
func (m *MockConsumer) CanConsume(arg0 Task) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CanConsume", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// CanConsume indicates an expected call of CanConsume.
func (mr *MockConsumerMockRecorder) CanConsume(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CanConsume", reflect.TypeOf((*MockConsumer)(nil).CanConsume), arg0)
}

// Consume mocks base method.
func (m *MockConsumer) Consume(arg0 context.Context, arg1 Task) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Consume", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Consume indicates an expected call of Consume.
func (mr *MockConsumerMockRecorder) Consume(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Consume", reflect.TypeOf((*MockConsumer)(nil).Consume), arg0, arg1)
}

// ResolveVersion mocks base method.
func (m *MockConsumer) ResolveVersion(arg0 *go_version.Version) VersionResolverVerdict {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResolveVersion", arg0)
	ret0, _ := ret[0].(VersionResolverVerdict)
	return ret0
}

// ResolveVersion indicates an expected call of ResolveVersion.
func (mr *MockConsumerMockRecorder) ResolveVersion(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResolveVersion", reflect.TypeOf((*MockConsumer)(nil).ResolveVersion), arg0)
}

// MockTask is a mock of Task interface.
type MockTask struct {
	ctrl     *gomock.Controller
	recorder *MockTaskMockRecorder
}

// MockTaskMockRecorder is the mock recorder for MockTask.
type MockTaskMockRecorder struct {
	mock *MockTask
}

// NewMockTask creates a new mock instance.
func NewMockTask(ctrl *gomock.Controller) *MockTask {
	mock := &MockTask{ctrl: ctrl}
	mock.recorder = &MockTaskMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTask) EXPECT() *MockTaskMockRecorder {
	return m.recorder
}

// Payload mocks base method.
func (m *MockTask) Payload() []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Payload")
	ret0, _ := ret[0].([]byte)
	return ret0
}

// Payload indicates an expected call of Payload.
func (mr *MockTaskMockRecorder) Payload() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Payload", reflect.TypeOf((*MockTask)(nil).Payload))
}

// Type mocks base method.
func (m *MockTask) Type() TaskType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Type")
	ret0, _ := ret[0].(TaskType)
	return ret0
}

// Type indicates an expected call of Type.
func (mr *MockTaskMockRecorder) Type() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Type", reflect.TypeOf((*MockTask)(nil).Type))
}

// Version mocks base method.
func (m *MockTask) Version() *go_version.Version {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Version")
	ret0, _ := ret[0].(*go_version.Version)
	return ret0
}

// Version indicates an expected call of Version.
func (mr *MockTaskMockRecorder) Version() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Version", reflect.TypeOf((*MockTask)(nil).Version))
}
